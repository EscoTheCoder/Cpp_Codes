#pragma once
#include "SparseMatrixTraits.h"
#include <map>
#include <iostream>

using namespace std;

/* H SparseMatrix κληρονομεί την SparseMatrixTraits και είναι και
   αυτή templated με το ίδιο template argument.
*/
template <typename T>
class SparseMatrix : public SparseMatrixTraits<T>
{
protected:

	/* Δεδομένης της 1 - 1 αντιστοιχείας μεταξύ συντεταγμένων
	   θέσης μέσα στον αραιό πίνακα και της αντίστοιχης τιμής,
	   η πιο προφανής εσωτερική υλοποίηση μπορεί να εκμεταλλευτεί
	   τη χρήση μιας έτοιμης δομής της STL που κάνει ακριβώς αυτή
	   την αντιστοίχιση μεταξύ ενός κλειδιού (εδώ τύπου Coordinate)
	   και τιμής (εδώ τύπου Τ).

	   Δύο είναι οι υποψήφιες κλάσεις της STL: unordered_map και map.
	   Δε μας ενδιαφέρουν οι "multimap" παραλλαγές, καθώς σε κάθε
	   θέση σώζουμε ένα ακριβώς δεδομένο. Η map έχει επιπλέον το
	   πλεονέκτημα να ταξινομεί τα στοιχεία που εισάγουμε, οπότε
	   όταν θα τη διατρέξουμε για εκτύπωση, θα τα έχουμε έτοιμα.

	   Θυμηθείτε ότι η θέση στον πίνακα για ένα στοιχείο που εισάγουμε
	   (operator () σε συνδυασμό με ανάθεση τιμής) δηλώνεται με τη δομή
	   Coordinates, η οποία μας παρέχει μηχανισμό σύγκρισης
	   (operator <) και άρα η std::map<Coordinates, T> ξέρει να
	   ταξινοομήσει τα στοιχεία που της περνάμε, καλώντας την default
	   πράξη less().
	*/
	std::map<Coordinates, T> data;

public:

	// Fix the friend ostream& operator<< for SparseMatrix
	friend std::ostream& operator<< (std::ostream& os, const SparseMatrix& matrix) {
		for (const auto& item : matrix.data) {
			os << item.first << ": " << item.second << std::endl;
		}
		return os;
	}

	/* Επιστρέφει σταθερή αναφορά, άρα δε μπορεί να χρησιμοποιηθεί αυτή
	   η έκδοση για εκχώρηση νέου στοιχείου στον πίνακα. Αν δεν υπάρχει
	   το στοιχείο στη θέση pos στον πίνακα, πρέπει να επιστραφεί το
	   "default" (μηδενικό) στοιχείο, και γι αυτό το λόγο καλούμε την
	   getNullElement<T>(). Σε κάποια άλλη περίπτωση, σε αντίστοιχη
	   αδυναμία μας να επιστρέψουμε αναφορά σε κάτι υπαρκτό, θα μπορούσαμε
	   να πετάξουμε κάποια εξαίρεση. Εδώ όμως, λόγω του συγκεκριμένου
	   ζητήματος, όπου έχουμε να κάνουμε με έναν πίνακα με "μηδενικά"
	   στοιχεία παντού εκτός από εκεί που έχουμε εμείς αναθέσει τιμές,
	   έχει νόημα η επιστροφή μιας default τιμής.
	*/
	const T& operator () (Coordinates pos) const override
	{
		auto elem = data.find(pos);
		cout << elem->first<<" "<<elem->second<<endl;
		if (elem != data.end())
		{
			return elem->second;
		}
		else
			return getNullElement<T>();
	}

	/* Η έκδοση του οperator () που επιστρέφει απλή αναφορά σε εσωτερικό στοιχείο
	   είναι η κατάλληλη να χρησιμοποιηθεί για αλλαγή στοιχείων, αφού μας επιτρέπει
	   να πάρουμε την αναφορά επιστροφής και να της αλλάξουμε το περιεχόμενο
	   (βλ. main). Επιπλέον, η μέθοδος αυτή πρέπει να εκτελεί και μια άλλη
	   λειτουργία, αυτή της εισαγωγής στοιχείων, οπότε αν δε βρεθεί η συντεταγμένη
	   που περνάμε στο map, προσθέτουμε στη συντεταγμένη αυτή νέο στοιχείο.
	*/
	T& operator () (Coordinates pos) override
	{
		auto elem = data.find(pos);
		if (elem != data.end())
		{
			return elem->second;
		}
		else
		{
			data[pos] = T();
			return data[pos];
		}
	}

	void clear() override
	{
		data.clear();
	}

	/* Δε χρειάζεται να κάνουμε κάτι εδώ με τη συγκεκριμένη υλοποίηση.
	*/
	SparseMatrix() : SparseMatrixTraits<T>() {}

	SparseMatrix(const SparseMatrix& other) {
		data = other.data;
	}


	/* Διατρέχουμε τα ήδη ταξινομημένα στοιχεία και απλά τα τυπώνουμε με
	   μορφοποίηση.
	*/
	void print() override
	{
		for (auto item : data)
		{
			std::cout << "\n";
			std::cout << "(" << item.first.row << ", " << item.first.col << "): " << item.second << " ";
		}
	}

	bool operator == (const SparseMatrix& right)
	{
		/* Για την ισότητα 2 πινάκων, ελέγχουμε πρώτα το προφανές: αν έχουν ίδιο
		   αριθμό στοιχείων.
		*/
		if (right.data.size() != data.size())
			return false;

		/* Για τον έλεγχο ισότητας των στοιχείων, μπορούμε να εκμεταλλευτούμε τον
		   τελεστή που φτιάξαμε. Κάνουμε τον έλεγχο συμμετρικά,
		   πρώτα εξετάζοντας τα στοιχεία του ενός SparseMatrix ως προς το δεύτερο
		   και μετά του δεύτερου ως προς τον πρώτο. Η συμμετρική αναζήτηση είναι
		   απαραίτητη καθώς ενδέχεται ο ένας πίνακας να είναι υποπίνακας του άλλου.
		*/
		for (auto item : data)
		{
			if (operator() (item.first) != right(item.first))
				return false;
		}

		for (auto item : right.data)
		{
			if (operator() (item.first) != right(item.first))
				return false;
		}

		return true;
	}

};